#include <iostream>

using namespace std;
// 本文件主要记录C++多态中虚的相关概念
/*
    1. 虚函数、纯虚函数
​        a. 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，
           它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），
           这样的话，编译器就可以使用后期绑定来达到多态了。
           纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
​        b. 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
​        c. 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。
           纯虚函数关注的是接口的统一性，实现由子类完成。
​        d. 带纯虚函数的类叫抽象类，这种类不能直接生成对象，
           而只有被继承，并重写其虚函数后，才能使用。
           抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
    2. 虚表指针、虚函数表
        a. 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
        b. 虚函数表：在程序只读数据段（.rodata section），存放虚函数指针，
           如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，
           在编译时根据类的声明创建。
    3. 虚继承
        a. 用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。
        b. 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，
           每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和
           虚基类表（不占用类对象的存储空间）
           （需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；
           当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
        c. 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基
           类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，
           这样就找到了虚基类成员，
           而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
    4. 虚继承、虚函数
        a. 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
        b. 不同之处：
​           ○ 虚继承
​               ■ 虚基类依旧存在继承类中，只占用存储空间
​               ■ 虚基类表存储的是虚基类相对直接继承类的偏移
​           ○ 虚函数
​               ■ 虚函数不占用存储空间
               ■ 虚函数表存储的是虚函数地址
*/

int main(int args, char* argv[]) 
{
    cout <<" --------------" <<endl;
    
    return 0;
}